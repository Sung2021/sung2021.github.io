knitr::opts_chunk$set(echo=F, fig.align = "center",
message=F, warning=F,
results = "markup",
error = TRUE,
highlight = TRUE,
prompt = FALSE,
tidy = FALSE)
library(dplyr)
library(ggplot2)
library(DESeq2)
library(edgeR)
library(reshape)
dir="~/Desktop/DF/MGH_Salvia/ITK-SYK/RNA_seq_SJ/"
count.raw = read.csv(paste0(dir,"rds/ITK_SYK_raw.count.filtered.24.04.12.csv"), row.names = 1)
count.raw = count.raw[,1:14]
count.raw [1:3,]
count.raw %>% nrow()
mm10_refGene = read.csv("~/Desktop/DF/ref/mm10_refGene_geneLength.csv", row.names = 1)
rownames(mm10_refGene) = mm10_refGene$gene_id
rowShared = intersect(rownames(count.raw), mm10_refGene$gene_id)
rowShared %>% length() # 16790
count_mtx = count.raw[rowShared,]
mm10_refGene = mm10_refGene[rowShared,]
gene_length = mm10_refGene$width
names(gene_length) = mm10_refGene$gene_id
gene_length
tpm_all = data.frame(matrix(nrow = nrow(count_mtx), ncol = ncol(count_mtx)))
tpm_all
rownames(tpm_all) = rownames(count_mtx)
colnames(tpm_all) = colnames(count_mtx)
tpm_all
tpm_all[1:3,]
count_mtx = count.raw
tpm_all = data.frame(matrix(nrow = nrow(count_mtx), ncol = ncol(count_mtx)))
rownames(tpm_all) = rownames(count_mtx)
colnames(tpm_all) = colnames(count_mtx)
for(i in 1:ncol(count_mtx)){
rpkm = count_mtx[,i]/(gene_length/1000)
rpkm_sum = sum(rpkm)
tpm <- rpkm / rpkm_sum * 1e6
tpm_all[,i] = tpm
}
warnings()
count_mtx = count.raw[rowShared,]
mm10_refGene = mm10_refGene[rowShared,]
gene_length = mm10_refGene$width
names(gene_length) = mm10_refGene$gene_id
tpm_all = data.frame(matrix(nrow = nrow(count_mtx), ncol = ncol(count_mtx)))
rownames(tpm_all) = rownames(count_mtx)
colnames(tpm_all) = colnames(count_mtx)
for(i in 1:ncol(count_mtx)){
rpkm = count_mtx[,i]/(gene_length/1000)
rpkm_sum = sum(rpkm)
tpm <- rpkm / rpkm_sum * 1e6
tpm_all[,i] = tpm
}
tpm_all
colSums(tpm_all)
tpm_all %>% write.csv(paste0(dir, "rds/tpm/ITK_SYK_RNASeq_mm10.GTF.tpm.24.04.15.csv"))
tpm %>% boxplot()
dir="~/Desktop/DF/MGH_Salvia/ITK-SYK/RNA_seq_SJ/"
tpm = read.csv(paste0(dir, "rds/tpm/ITK_SYK_RNASeq_mm10.GTF.tpm.24.04.15.csv"), row.names = 1)
tpm %>% boxplot()
knitr::opts_chunk$set(echo=F, fig.align = "center",
message=F, warning=F,
results = "markup",
error = TRUE,
highlight = TRUE,
prompt = FALSE,
tidy = FALSE)
library(dplyr)
library(ggplot2)
library(DESeq2)
library(edgeR)
library(reshape)
dir="~/Desktop/DF/MGH_Salvia/ITK-SYK/RNA_seq_SJ/"
# fc=readRDS(paste0(dir,"rds/fc.sym.23.03.15.rds"))
# fc.symbol = fc %>% filter(symbol !="NA")
# rownames(fc.symbol) = fc.symbol$symbol
# # fc.symbol[1:3,]
#
# # Rename column names
# colnames(fc.symbol) = sub("Aligned.sortedByCoord.out.bam", "", colnames(fc.symbol))
#
# count.mtx = fc.symbol[,1:14] # select the read part only
#
# colnames(count.mtx) = sub("_.*", "", colnames(count.mtx))
#
# count.mtx %>% write.csv(paste0(dir,"rds/fc.sym.count.mtx.24.04.12.csv"))
count.raw = read.csv(paste0(dir,"rds/fc.sym.count.mtx.24.04.12.csv"), row.names = 1)
# row sums =0 filtering out
# Calculate row sums
row_sums <- rowSums(count.raw)
# Filter out rows with row sums equal to 0
count.raw_rowsum0filtered <- count.raw[row_sums >= 3, ]
count.raw_rowsum0filtered$gene = rownames(count.raw_rowsum0filtered)
count.raw_rowsum0filtered = count.raw_rowsum0filtered %>%
filter(!(stringr::str_detect(gene, "^[A-Z0-9]+$")))
tmp.count = count.raw_rowsum0filtered
# This dataset was contaminated by some human genes
# COX1, COX2
df = tmp.count %>% mutate(gene = rownames(.)) %>% reshape::melt()
hgs = 150000
df %>% mutate(label = ifelse(value >= hgs, gene,"")) %>%
ggplot(aes(variable, value)) + geom_boxplot() +
ggrepel::geom_text_repel(aes(label=label),size=3, hjust=-0.5, vjust=-0.5) +
labs(title = paste0("read cutoff : ", hgs))
df %>% mutate(label = ifelse(value >= hgs, gene,"")) %>%
ggplot(aes(variable, value)) + geom_boxplot() +
ggrepel::geom_text_repel(aes(label=label),size=3, hjust=-0.5, vjust=-0.5) +
labs(title = paste0("read cutoff : ", hgs)) +scale_y_sqrt()
df %>% mutate(label = ifelse(value >= hgs, gene,"")) %>% dplyr::count(label) %>% arrange(desc(n))
gs_removal = c("Eef1a1", "Rn45s","Actb")
count.raw_rowsum0filtered = count.raw_rowsum0filtered[!(rownames(count.raw_rowsum0filtered) %in% gs_removal),]
# I don't remove genes with the expression of few samples.
tmp = count.raw_rowsum0filtered
# Immunoglobulin genes removal
ig_genes = rownames(tmp)[grepl("Ig", rownames(tmp))]
genes_toRemove = c(ig_genes,"Jchain", paste0("Cd79",c("a","b")))
tmp = tmp[!(rownames(tmp) %in% genes_toRemove),]
tmp %>% dim() # 18241
count.raw_rowsum0filtered = tmp
ig_genes
# tpm %>% boxplot()
tpm %>% DT::datatable(extensions = "Buttons",
options = list(autoWidth = TRUE,
fixedHeader = TRUE,
dom="Bfrtip", buttons=c("csv","excel")))
library(clusterProfiler)
hallmark <- msigdbr::msigdbr(species = "Mus musculus", category = "H") %>%
dplyr::select(gs_name, gene_symbol)
library(corto)
test = ssgsea(tpm,hallmark)
test
hallmark
hallmark <- msigdbr::msigdbr(species = "Mus musculus", category = "H") %>% dplyr::select(gs_name, gene_symbol)
hallmark
gmt1 = clusterProfiler::read.gmt(paste0(dir,"gmt/PLASMA_MEMBRANE.v2023.2.Hs.gmt"))
# 필요한 패키지를 로드합니다.
library(dplyr)
library(purrr)
# 예시 데이터를 생성합니다. 실제 데이터는 이보다 훨씬 클 수 있습니다.
hallmark <- tibble(
gs_name = c("HALLMARK_ADIPOGENESIS", "HALLMARK_ADIPOGENESIS", "HALLMARK_T_CELL_ACTIVATION", "HALLMARK_T_CELL_ACTIVATION"),
gene_symbol = c("Abca1", "Abcb8", "Acaa2", "Acadm")
)
# gs_name 별로 gene_symbol들을 리스트로 그룹핑합니다.
gene_list_by_gs_name <- hallmark %>%
group_by(gs_name) %>%
summarise(gene_list = list(gene_symbol), .groups = "drop")
# 결과를 확인합니다.
print(gene_list_by_gs_name)
hallmark$gs_name %>% unique()
hallmark <- msigdbr::msigdbr(species = "Mus musculus", category = "H") %>%
dplyr::select(gs_name, gene_symbol)
hallmark$gs_name %>% unique()
gs1 = hallmark %>% filter(gs_name == "HALLMARK_ADIPOGENESIS") %>%
select(gene_symbol) %>% pull()
## Perform ssgsea
## Input data : tpm (count.mtx is accepted as well)
test = ssgsea(tpm,list(HALLMARK_ADIPOGENESIS = gs1))
test
gsub(hallmark$gene_symbol, "HALLMARK_","")
gsub("HALLMARK_","",hallmark$gene_symbol)
gsub("HALLMARK_","",hallmark$gs_name)
hallmark$gs_name = gsub("HALLMARK_","",hallmark$gs_name)
hallmark$gs_name %>% unique()
hallmark_gs_list = hallmark$gs_name %>% unique()
i = 1
pathway = hallmark_gs_list[i]
hallmark[hallmark$gs_name == pathway,2]
hallmark <- msigdbr::msigdbr(species = "Mus musculus", category = "H") %>%
dplyr::select(gs_name, gene_symbol) %>% data.frame()
hallmark$gs_name = gsub("HALLMARK_","",hallmark$gs_name)
hallmark_gs_list = hallmark$gs_name %>% unique()
gs1 = hallmark %>% filter(gs_name == "HALLMARK_ADIPOGENESIS") %>%
select(gene_symbol) %>% pull()
i = 1
pathway = hallmark_gs_list[i]
hallmark[hallmark$gs_name == pathway,2]
gs = hallmark[hallmark$gs_name == pathway,2]
hallmarkList = list()
hallmarkList = list()
for(i in 1:length(hallmark_gs_list)){
pathway = hallmark_gs_list[i]
gs = hallmark[hallmark$gs_name == pathway,2]
hallmarkList[[pathway]] = gs
}
hallmarkList
## Perform ssgsea
## Input data : tpm (count.mtx is accepted as well)
test = ssgsea(tpm,hallmarkList)
test
## p value of ssgsea
pval = corto::z2p(test)
colnames(pval) = rownames(test.df)
## Reshape it to plot
test.df = test %>% t() %>% data.frame()
rownames(test.df) = colnames(tpm)
## p value of ssgsea
pval = corto::z2p(test)
colnames(pval) = rownames(test.df)
test.df
## Heatmap
my.color=c(colorRampPalette(colors = c("#2874A6","white"))(60),
colorRampPalette(colors = c("white","#D35400"))(90))
t(test.df) %>% pheatmap::pheatmap(color = my.color) # Simple heatmap
## Heatmap
my.color=c(colorRampPalette(colors = c("#2874A6","white"))(60),
colorRampPalette(colors = c("white","#D35400"))(80))
t(test.df) %>% pheatmap::pheatmap(color = my.color) # Simple heatmap
## Heatmap
my.color=c(colorRampPalette(colors = c("#2874A6","white"))(60),
colorRampPalette(colors = c("white","#D35400"))(70))
t(test.df) %>% pheatmap::pheatmap(color = my.color) # Simple heatmap
pval
library(pheatmap)
# 데이터 프레임 및 색상 팔레트 설정
test.df <- matrix(rnorm(100), nrow = 10)
colnames(test.df) <- paste("Col", 1:10)
rownames(test.df) <- paste("Row", 1:10)
# 여기서 my.color는 색상 팔레트를 정의합니다.
# 예: my.color <- colorRampPalette(c("blue", "white", "red"))(n = 299)
my.color <- colorRampPalette(c("blue", "white", "red"))(n = 299)
# 히트맵 생성
heatmap <- pheatmap(test.df, color = my.color, silent = TRUE)
# 다른 데이터 프레임에서 숫자를 가져와서 사용할 예정
# 이 데이터 프레임은 test.df와 동일한 차원을 가져야 합니다.
additional.df <- matrix(round(rnorm(100, 10, 5)), nrow = 10)
# 히트맵 위에 숫자 추가
for (i in 1:nrow(test.df)) {
for (j in 1:ncol(test.df)) {
text(heatmap$gtable$grobs[[which(heatmap$gtable$layout$name == "heatmap")]]$children[[1]]$x[j],
heatmap$gtable$grobs[[which(heatmap$gtable$layout$name == "heatmap")]]$children[[1]]$y[i],
additional.df[i, j], pos = 4, cex = 0.8, col = "black")
}
}
t(test.df)
t(test.df) %>% pheatmap::pheatmap(color = my.color) # Simple heatmap
test.df = test %>% t() %>% data.frame()
rownames(test.df) = colnames(tpm)
## p value of ssgsea
pval = corto::z2p(test)
colnames(pval) = rownames(test.df)
## Heatmap
my.color=c(colorRampPalette(colors = c("#2874A6","white"))(60),
colorRampPalette(colors = c("white","#D35400"))(70))
t(test.df) %>% pheatmap::pheatmap(color = my.color) # Simple heatmap
t(test.df) %>% pheatmap::pheatmap(color = my.color,
cluster_rows = F,
cluster_cols = F) # Simple heatmap
t(pval) %>% pheatmap::pheatmap(color = my.color,
cluster_rows = F,
cluster_cols = F) # Simple heatmap
pval %>% pheatmap::pheatmap(color = my.color,
cluster_rows = F,
cluster_cols = F) # Simple heatmap
input.data = pval[pval<=0.05]
input.data
pval
input.data = (pval<=0.05)
input.data
input.data %>% pheatmap::pheatmap(color = my.color,
cluster_rows = F,
cluster_cols = F) # Simple heatmap
input.data
as.integer(input.data) %>% pheatmap::pheatmap(color = my.color,
cluster_rows = F,
cluster_cols = F) # Simple heatmap
input.data[] <- +input.data
input.data
input.data %>% pheatmap::pheatmap(color = my.color,
cluster_rows = F,
cluster_cols = F) # Simple heatmap
# 이 구문은 데이터 프레임 input.data의 모든 요소를 선택하고 이 요소들에 대해 변환 작업을 수행합니다. 여기서 []는 데이터 프레임의 모든 요소를 선택하는 인덱싱 연산자입니다. 이 연산자를 사용하면 데이터 프레임의 구조는 그대로 유지되면서 내부의 값만 변경할 수 있습니다.
#
# 2. +input.data
# + 연산자는 R에서 수치 연산에 사용되며, 이 경우에는 데이터 프레임의 각 논리값 요소(TRUE 또는 FALSE)에 적용됩니다. R에서 논리값은 내부적으로 TRUE가 1로, FALSE가 0으로 저장되어 있습니다. 따라서 + 연산자를 논리값에 적용하면, R은 자동으로 이 논리값을 해당하는 수치 값(1 또는 0)으로 변환합니다.
#
# 이 방법의 장점은:
#
#   간결함: 한 줄로 모든 변환을 완료할 수 있습니다.
# 효율성: 복잡한 루프나 조건문 없이 전체 데이터 프레임에 대한 연산을 수행할 수 있습니다.
# 데이터 프레임 구조 유지: 이 방식은 데이터 프레임의 행과 열 구조를 그대로 유지하면서 값만 변경합니다.
input.data %>% pheatmap::pheatmap(color = c("grey","salmon"),
cluster_rows = F,
cluster_cols = F) # Simple heatmap
# 이 구문은 데이터 프레임 input.data의 모든 요소를 선택하고 이 요소들에 대해 변환 작업을 수행합니다. 여기서 []는 데이터 프레임의 모든 요소를 선택하는 인덱싱 연산자입니다. 이 연산자를 사용하면 데이터 프레임의 구조는 그대로 유지되면서 내부의 값만 변경할 수 있습니다.
#
# 2. +input.data
# + 연산자는 R에서 수치 연산에 사용되며, 이 경우에는 데이터 프레임의 각 논리값 요소(TRUE 또는 FALSE)에 적용됩니다. R에서 논리값은 내부적으로 TRUE가 1로, FALSE가 0으로 저장되어 있습니다. 따라서 + 연산자를 논리값에 적용하면, R은 자동으로 이 논리값을 해당하는 수치 값(1 또는 0)으로 변환합니다.
#
# 이 방법의 장점은:
#
#   간결함: 한 줄로 모든 변환을 완료할 수 있습니다.
# 효율성: 복잡한 루프나 조건문 없이 전체 데이터 프레임에 대한 연산을 수행할 수 있습니다.
# 데이터 프레임 구조 유지: 이 방식은 데이터 프레임의 행과 열 구조를 그대로 유지하면서 값만 변경합니다.
input.data %>% pheatmap::pheatmap(color = c("grey","salmon"),
cluster_rows = F,
cluster_cols = F,color_bar = FALSE ) # Simple heatmap
# 이 구문은 데이터 프레임 input.data의 모든 요소를 선택하고 이 요소들에 대해 변환 작업을 수행합니다. 여기서 []는 데이터 프레임의 모든 요소를 선택하는 인덱싱 연산자입니다. 이 연산자를 사용하면 데이터 프레임의 구조는 그대로 유지되면서 내부의 값만 변경할 수 있습니다.
#
# 2. +input.data
# + 연산자는 R에서 수치 연산에 사용되며, 이 경우에는 데이터 프레임의 각 논리값 요소(TRUE 또는 FALSE)에 적용됩니다. R에서 논리값은 내부적으로 TRUE가 1로, FALSE가 0으로 저장되어 있습니다. 따라서 + 연산자를 논리값에 적용하면, R은 자동으로 이 논리값을 해당하는 수치 값(1 또는 0)으로 변환합니다.
#
# 이 방법의 장점은:
#
#   간결함: 한 줄로 모든 변환을 완료할 수 있습니다.
# 효율성: 복잡한 루프나 조건문 없이 전체 데이터 프레임에 대한 연산을 수행할 수 있습니다.
# 데이터 프레임 구조 유지: 이 방식은 데이터 프레임의 행과 열 구조를 그대로 유지하면서 값만 변경합니다.
input.data %>% pheatmap::pheatmap(color = c("grey","salmon"),
cluster_rows = F,
cluster_cols = F,color_bar = FALSE ) # Simple heatmap
# 이 구문은 데이터 프레임 input.data의 모든 요소를 선택하고 이 요소들에 대해 변환 작업을 수행합니다. 여기서 []는 데이터 프레임의 모든 요소를 선택하는 인덱싱 연산자입니다. 이 연산자를 사용하면 데이터 프레임의 구조는 그대로 유지되면서 내부의 값만 변경할 수 있습니다.
#
# 2. +input.data
# + 연산자는 R에서 수치 연산에 사용되며, 이 경우에는 데이터 프레임의 각 논리값 요소(TRUE 또는 FALSE)에 적용됩니다. R에서 논리값은 내부적으로 TRUE가 1로, FALSE가 0으로 저장되어 있습니다. 따라서 + 연산자를 논리값에 적용하면, R은 자동으로 이 논리값을 해당하는 수치 값(1 또는 0)으로 변환합니다.
#
# 이 방법의 장점은:
#
#   간결함: 한 줄로 모든 변환을 완료할 수 있습니다.
# 효율성: 복잡한 루프나 조건문 없이 전체 데이터 프레임에 대한 연산을 수행할 수 있습니다.
# 데이터 프레임 구조 유지: 이 방식은 데이터 프레임의 행과 열 구조를 그대로 유지하면서 값만 변경합니다.
input.data %>% pheatmap::pheatmap(color = c("grey99","salmon"),
cluster_rows = F,
cluster_cols = F) # Simple heatmap
## Heatmap
my.color=c(colorRampPalette(colors = c("#2874A6","white"))(60),
colorRampPalette(colors = c("white","#D35400"))(70))
t(test.df) %>% pheatmap::pheatmap(color = my.color,
cluster_rows = F,
cluster_cols = F,
main = "ssGSEA of HALLMARK pathways") # Simple heatmap
## Heatmap
my.color=c(colorRampPalette(colors = c("#2874A6","white"))(60),
colorRampPalette(colors = c("white","#D35400"))(70))
t(test.df) %>% pheatmap::pheatmap(color = my.color,
cluster_rows = F,
cluster_cols = F,
main = "ssGSEA of HALLMARK pathways") # Simple heatmap
## Heatmap
my.color=c(colorRampPalette(colors = c("#2874A6","white"))(60),
colorRampPalette(colors = c("white","#D35400"))(70))
t(test.df) %>% pheatmap::pheatmap(color = my.color,
cluster_rows = F,
cluster_cols = F,
main = "ssGSEA of HALLMARK pathways") # Simple heatmap
## Heatmap
my.color=c(colorRampPalette(colors = c("#2874A6","white"))(60),
colorRampPalette(colors = c("white","#D35400"))(70))
t(test.df) %>% pheatmap::pheatmap(color = my.color,
cluster_rows = F,
cluster_cols = F,
main = "ssGSEA of HALLMARK pathways",
gaps_col = 5,6,10) # Simple heatmap
## Heatmap
my.color=c(colorRampPalette(colors = c("#2874A6","white"))(60),
colorRampPalette(colors = c("white","#D35400"))(70))
t(test.df) %>% pheatmap::pheatmap(color = my.color,
cluster_rows = F,
cluster_cols = F,
main = "ssGSEA of HALLMARK pathways",
gaps_col = c(5,6,10)) # Simple heatmap
knitr::opts_chunk$set(echo=T, fig.align = "center", eval = F,
message=F, warning=F,
results = "markup",
error = TRUE,
highlight = TRUE,
prompt = FALSE,
tidy = FALSE)
# ssGSEA
# Single sample GSEA
library(corto)
## Create hallmark pathway list
hallmark <- msigdbr::msigdbr(species = "Mus musculus", category = "H") %>%
dplyr::select(gs_name, gene_symbol) %>% data.frame()
hallmark$gs_name = gsub("HALLMARK_","",hallmark$gs_name)
hallmark_gs_list = hallmark$gs_name %>% unique()
hallmarkList = list()
for(i in 1:length(hallmark_gs_list)){
pathway = hallmark_gs_list[i]
gs = hallmark[hallmark$gs_name == pathway,2]
hallmarkList[[pathway]] = gs
}
tpm[1:3,]
tpm.sample = tpm[,c(1:3,5:8)]
tpm.sample[1:3,]
tpm.sample = tpm[,c(1:3,8:12)]
tpm.sample[1:3,]
tpm.sample = tpm[,c(1:3,8:14)]
tpm.sample[1:3,]
tpm.sample = tpm[,c(1:3,8:13)]
tpm.sample[1:3,]
colnames(tpm.sample)
colnames(tpm.sample) = c(paste0("condition", 1:9))
tpm.sample[1:3,]
tpm.sample %>% write.csv("~/Desktop/tpm.sample.csv")
library(dplyr)
library(ggplot2)
library(DESeq2)
library(edgeR)
library(reshape)
library(dplyr)
# First, create vectors for each column
PC1 <- c(-12.48417792, -11.60784426, -10.95278299, -9.234550928, -12.93624321,
-10.6807003, -0.065991014, -5.536146627, -8.234377152, 31.11284796,
19.72396967, 21.42781676, 45.91067912)
PC2 <- c(0.352316398, 0.203888683, -0.460533257, 1.467805113, 1.046447489,
-0.74510519, -0.458497168, -0.925433457, -0.656565276, 2.23485637,
-0.519156466, -2.6308456, -5.790269992)
group <- c("CondA", "CondA", "CondA", "CondA", "CondA",
"CondB", "CondB", "CondB", "CondB", "Ctl",
"Ctl", "Ctl", "Ctl")
sample <- c("CondA1", "CondA2", "CondA3", "CondA4", "CondA5",
"CondB1", "CondB2", "CondB3", "CondB4", "Ctl1",
"Ctl2", "Ctl3", "Ctl4")
name <- c("CondA1", "CondA2", "CondA3", "CondA4", "CondA5",
"CondB1", "CondB2", "CondB3", "CondB4", "Ctl1",
"Ctl2", "Ctl3", "Ctl4")
# Create the data frame
pcaData <- data.frame(PC1, PC2, group, sample, name)
PCA_var <- c(0.82990806, 0.07676304)
ggplot(pcaData, aes(x = PC1, y = PC2, fill = group)) +
geom_point(size = 4, alpha = 0.6, shape = 21, color = "black", stroke = 0.5)  +
ggrepel::geom_text_repel(aes(label=name),
color="grey6", size=3, hjust= -0.3, vjust=-0.3) +
labs(x = paste("PC1: ", round(100 * PCA_var[1]), "% variance"),
y = paste("PC2: ", round(100 * PCA_var[2]), "% variance")) +
theme_bw() +
theme(legend.title = element_blank()) +
ggtitle("PCA") +
labs(caption = " ")
tpm = read.csv("sample_data/tpm.sample.csv", row.names = 1)
# ssGSEA
# Single sample GSEA
library(corto)
## Create hallmark pathway list
hallmark <- msigdbr::msigdbr(species = "Mus musculus", category = "H") %>%
dplyr::select(gs_name, gene_symbol) %>% data.frame()
hallmark$gs_name = gsub("HALLMARK_","",hallmark$gs_name)
hallmark_gs_list = hallmark$gs_name %>% unique()
hallmarkList = list()
for(i in 1:length(hallmark_gs_list)){
pathway = hallmark_gs_list[i]
gs = hallmark[hallmark$gs_name == pathway,2]
hallmarkList[[pathway]] = gs
}
## Perform ssgsea
## Input data : tpm (count.mtx is accepted as well)
test = ssgsea(tpm,hallmarkList)
## Reshape it to plot
test.df = test %>% t() %>% data.frame()
rownames(test.df) = colnames(tpm)
## p value of ssgsea
pval = corto::z2p(test)
colnames(pval) = rownames(test.df)
## Heatmap
my.color=c(colorRampPalette(colors = c("#2874A6","white"))(60),
colorRampPalette(colors = c("white","#D35400"))(70))
t(test.df) %>% pheatmap::pheatmap(color = my.color,
cluster_rows = F,
cluster_cols = F,
main = "ssGSEA of HALLMARK pathways",
gaps_col = c(3,6)) # Simple heatmap
input.data = (pval<=0.05)
input.data[] <- +input.data
# 1. input.data[] <- ...
# 이 구문은 데이터 프레임 input.data의 모든 요소를 선택하고 이 요소들에 대해 변환 작업을 수행합니다. 여기서 []는 데이터 프레임의 모든 요소를 선택하는 인덱싱 연산자입니다. 이 연산자를 사용하면 데이터 프레임의 구조는 그대로 유지되면서 내부의 값만 변경할 수 있습니다.
#
# 2. +input.data
# + 연산자는 R에서 수치 연산에 사용되며, 이 경우에는 데이터 프레임의 각 논리값 요소(TRUE 또는 FALSE)에 적용됩니다. R에서 논리값은 내부적으로 TRUE가 1로, FALSE가 0으로 저장되어 있습니다. 따라서 + 연산자를 논리값에 적용하면, R은 자동으로 이 논리값을 해당하는 수치 값(1 또는 0)으로 변환합니다.
#
# 이 방법의 장점은:
#
#   간결함: 한 줄로 모든 변환을 완료할 수 있습니다.
# 효율성: 복잡한 루프나 조건문 없이 전체 데이터 프레임에 대한 연산을 수행할 수 있습니다.
# 데이터 프레임 구조 유지: 이 방식은 데이터 프레임의 행과 열 구조를 그대로 유지하면서 값만 변경합니다.
input.data %>% pheatmap::pheatmap(color = c("grey99","salmon"),
cluster_rows = F,
cluster_cols = F,
main = "Significance by p value",
gaps_col = c(3,6)) # Simple heatmap
